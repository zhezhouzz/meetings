# summary

+ I am working on the implementation of the example mentioned last meeting. As I will reuse the data-driven part of implementation of last submission, I focus on the other parts: assume the under-approximation of library functions are given, how to generate corresponding input and convert the input to new sample while it does not lead a bug(the execution path of that input will diverge from the expected path, the diverge point is the spec we need to refine). I have almost finished the symbolic execution part(convert the condition to the input is missing), I will try to finish the whole example in the following weak.
+  I discussed with Ben about the "backward" bug finding: the symbolic execution should start from the buggy location and go backward to the assumption; multi-specification of one library functions, as the under-approximate specs are uncomparable thus we probably should keep several specs for one function.
+  Ben recommand me to write a draft of related work which compare symbolic execution and my method. I also decided to write a clear version of the algorithm after I implemented the example. 
